
#include "base32.h"

#include <smmintrin.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <x86intrin.h> // update if we need to support Windows.

static int8_t zero_masks[32] = {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
                                0,  0,  0,  0,  0,  -1, -1, -1, -1, -1, -1,
                                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
//////////////////////////
/// Source: Faster Base64 Encoding and Decoding Using AVX2 Instructions,
///         https://arxiv.org/abs/1704.00605
//////////////////////////
// credit @aqrit
//////////////////////////
size_t base32hex_simd(uint8_t *dst, const uint8_t *src) {
  bool valid = true;
  const __m128i delta_check =
      _mm_setr_epi8(-16, -32, -48, 70, -65, 41, -97, 9, 0, 0, 0, 0, 0, 0, 0, 0);
  const __m128i delta_rebase =
      _mm_setr_epi8(0, 0, 0, -48, -55, -55, -87, -87, 0, 0, 0, 0, 0, 0, 0, 0);
  const uint8_t *srcinit = src;
  do {
    __m128i v = _mm_loadu_si128((__m128i *)src);

    __m128i hash_key = _mm_and_si128(_mm_srli_epi32(v, 4), _mm_set1_epi8(0x0F));
    __m128i check = _mm_add_epi8(_mm_shuffle_epi8(delta_check, hash_key), v);
    v = _mm_add_epi8(v, _mm_shuffle_epi8(delta_rebase, hash_key));
    unsigned int m = (unsigned)_mm_movemask_epi8(check);

    if (m) {
      int length = __builtin_ctz(m);
      if (length == 0) {
        break;
      }
      src += length;
      __m128i zero_mask =
          _mm_loadu_si128((__m128i *)(zero_masks + 16 - length));
      v = _mm_andnot_si128(zero_mask, v);
      valid = false;
    } else { // common case
      src += 16;
    }
    v = _mm_maddubs_epi16(v, _mm_set1_epi32(0x01200120));
    v = _mm_madd_epi16(
        v, _mm_set_epi32(0x00010400, 0x00104000, 0x00010400, 0x00104000));
    // ...00000000`0000eeee`efffffgg`ggghhhhh`00000000`aaaaabbb`bbcccccd`dddd0000
    v = _mm_or_si128(v, _mm_srli_epi64(v, 48));
    v = _mm_shuffle_epi8(
        v, _mm_set_epi8(0, 0, 0, 0, 0, 0, 12, 13, 8, 9, 10, 4, 5, 0, 1, 2));

    /* decoded 10 bytes... but write 16 cause why not? */
    _mm_storeu_si128((__m128i *)dst, v);
    dst += 10;
  } while (valid);

  return (size_t)(src - srcinit);
}

size_t base32hex_avx(uint8_t *dst, const uint8_t *src) {
  static int8_t zero_masks256[64] = {
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
  bool valid = true;
  const __m256i delta_check = _mm256_setr_epi8(
      -16, -32, -48, 70, -65, 41, -97, 9, 0, 0, 0, 0, 0, 0, 0, 0, -16, -32, -48,
      70, -65, 41, -97, 9, 0, 0, 0, 0, 0, 0, 0, 0);
  const __m256i delta_rebase = _mm256_setr_epi8(
      0, 0, 0, -48, -55, -55, -87, -87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -48,
      -55, -55, -87, -87, 0, 0, 0, 0, 0, 0, 0, 0);
  const uint8_t *srcinit = src;
  do {
    __m256i v = _mm256_loadu_si256((__m256i *)src);

    __m256i hash_key =
        _mm256_and_si256(_mm256_srli_epi32(v, 4), _mm256_set1_epi8(0x0F));
    __m256i check =
        _mm256_add_epi8(_mm256_shuffle_epi8(delta_check, hash_key), v);
    v = _mm256_add_epi8(v, _mm256_shuffle_epi8(delta_rebase, hash_key));
    unsigned int m = (unsigned)_mm256_movemask_epi8(check);

    if (m) {
      int length = __builtin_ctz(m);
      if (length == 0) {
        break;
      }
      src += length;
      __m256i zero_mask =
          _mm256_loadu_si256((__m256i *)(zero_masks256 + 32 - length));
      v = _mm256_andnot_si256(zero_mask, v);
      valid = false;
    } else { // common case
      src += 32;
    }
    v = _mm256_maddubs_epi16(v, _mm256_set1_epi32(0x01200120));
    v = _mm256_madd_epi16(
        v, _mm256_set_epi32(0x00010400, 0x00104000, 0x00010400, 0x00104000,
                            0x00010400, 0x00104000, 0x00010400, 0x00104000));
    // ...00000000`0000eeee`efffffgg`ggghhhhh`00000000`aaaaabbb`bbcccccd`dddd0000
    v = _mm256_or_si256(v, _mm256_srli_epi64(v, 48));
    v = _mm256_shuffle_epi8(
        v, _mm256_set_epi8(0, 0, 0, 0, 0, 0, 12, 13, 8, 9, 10, 4, 5, 0, 1, 2, 0,
                           0, 0, 0, 0, 0, 12, 13, 8, 9, 10, 4, 5, 0, 1, 2));
    // 5. store bytes
    _mm_storeu_si128((__m128i *)dst, _mm256_castsi256_si128(v));
    dst += 10;
    _mm_storeu_si128((__m128i *)dst, _mm256_extractf128_si256(v, 1));
    dst += 10;

  } while (valid);

  return (size_t)(src - srcinit);
}

/* if we didn't have to worry about an unknown number of base32 digits...
 then we could just unroll and sign-extend to detect bad chars
*/
size_t base32hex_simple(uint8_t *dst, const uint8_t *src) {
  static const uint8_t table[256] = {
      32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
      32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
      32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
      0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  32, 32, 32, 32, 32, 32,
      32, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
      25, 26, 27, 28, 29, 30, 31, 32, 32, 32, 32, 32, 32, 32, 32, 32,
      32, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
      25, 26, 27, 28, 29, 30, 31, 32, 32, 32, 32, 32, 32, 32, 32, 32,

      32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
      32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
      32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
      32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
      32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
      32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
      32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
      32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
  };
  bool valid = true;
  const uint8_t *srcinit = src;

  do {
    uint64_t r = 0;
    for (size_t i = 0; i < 8; i++) {
      uint8_t x = table[*src];
      src++;
      if (x > 31) {
        r <<= (5 * (8 - i));
        valid = false;
        break;
      }
      r <<= 5;
      r |= x;
    }
    r = (unsigned long int)_bswap64((long long int)r);
    uint64_t rs = ((uint64_t)r >> (3 * 8));
    memcpy(dst, (const char *)&rs, 8);
    dst += 5;
  } while (valid);
  return (size_t)(src - srcinit);
}
size_t base32hex_fast(uint8_t *dst, const uint8_t *src) {
  // clang-format off
  static const int64_t table0[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 34359738368, 68719476736, 103079215104, 137438953472, 171798691840, 206158430208, 240518168576, 274877906944, 309237645312, -1, -1, -1, -1, -1, -1, -1, 343597383680, 377957122048, 412316860416, 446676598784, 481036337152, 515396075520, 549755813888, 584115552256, 618475290624, 652835028992, 687194767360, 721554505728, 755914244096, 790273982464, 824633720832, 858993459200, 893353197568, 927712935936, 962072674304, 996432412672, 1030792151040, 1065151889408, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 343597383680, 377957122048, 412316860416, 446676598784, 481036337152, 515396075520, 549755813888, 584115552256, 618475290624, 652835028992, 687194767360, 721554505728, 755914244096, 790273982464, 824633720832, 858993459200, 893353197568, 927712935936, 962072674304, 996432412672, 1030792151040, 1065151889408, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
  static const int64_t table1[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1073741824, 2147483648, 3221225472, 4294967296, 5368709120, 6442450944, 7516192768, 8589934592, 9663676416, -1, -1, -1, -1, -1, -1, -1, 10737418240, 11811160064, 12884901888, 13958643712, 15032385536, 16106127360, 17179869184, 18253611008, 19327352832, 20401094656, 21474836480, 22548578304, 23622320128, 24696061952, 25769803776, 26843545600, 27917287424, 28991029248, 30064771072, 31138512896, 32212254720, 33285996544, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10737418240, 11811160064, 12884901888, 13958643712, 15032385536, 16106127360, 17179869184, 18253611008, 19327352832, 20401094656, 21474836480, 22548578304, 23622320128, 24696061952, 25769803776, 26843545600, 27917287424, 28991029248, 30064771072, 31138512896, 32212254720, 33285996544, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
  static const int64_t table2[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 33554432, 67108864, 100663296, 134217728, 167772160, 201326592, 234881024, 268435456, 301989888, -1, -1, -1, -1, -1, -1, -1, 335544320, 369098752, 402653184, 436207616, 469762048, 503316480, 536870912, 570425344, 603979776, 637534208, 671088640, 704643072, 738197504, 771751936, 805306368, 838860800, 872415232, 905969664, 939524096, 973078528, 1006632960, 1040187392, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 335544320, 369098752, 402653184, 436207616, 469762048, 503316480, 536870912, 570425344, 603979776, 637534208, 671088640, 704643072, 738197504, 771751936, 805306368, 838860800, 872415232, 905969664, 939524096, 973078528, 1006632960, 1040187392, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
  static const int64_t table3[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1048576, 2097152, 3145728, 4194304, 5242880, 6291456, 7340032, 8388608, 9437184, -1, -1, -1, -1, -1, -1, -1, 10485760, 11534336, 12582912, 13631488, 14680064, 15728640, 16777216, 17825792, 18874368, 19922944, 20971520, 22020096, 23068672, 24117248, 25165824, 26214400, 27262976, 28311552, 29360128, 30408704, 31457280, 32505856, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10485760, 11534336, 12582912, 13631488, 14680064, 15728640, 16777216, 17825792, 18874368, 19922944, 20971520, 22020096, 23068672, 24117248, 25165824, 26214400, 27262976, 28311552, 29360128, 30408704, 31457280, 32505856, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
  static const int64_t table4[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 32768, 65536, 98304, 131072, 163840, 196608, 229376, 262144, 294912, -1, -1, -1, -1, -1, -1, -1, 327680, 360448, 393216, 425984, 458752, 491520, 524288, 557056, 589824, 622592, 655360, 688128, 720896, 753664, 786432, 819200, 851968, 884736, 917504, 950272, 983040, 1015808, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 327680, 360448, 393216, 425984, 458752, 491520, 524288, 557056, 589824, 622592, 655360, 688128, 720896, 753664, 786432, 819200, 851968, 884736, 917504, 950272, 983040, 1015808, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
  static const int64_t table5[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1024, 2048, 3072, 4096, 5120, 6144, 7168, 8192, 9216, -1, -1, -1, -1, -1, -1, -1, 10240, 11264, 12288, 13312, 14336, 15360, 16384, 17408, 18432, 19456, 20480, 21504, 22528, 23552, 24576, 25600, 26624, 27648, 28672, 29696, 30720, 31744, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10240, 11264, 12288, 13312, 14336, 15360, 16384, 17408, 18432, 19456, 20480, 21504, 22528, 23552, 24576, 25600, 26624, 27648, 28672, 29696, 30720, 31744, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
  static const int64_t table6[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 32, 64, 96, 128, 160, 192, 224, 256, 288, -1, -1, -1, -1, -1, -1, -1, 320, 352, 384, 416, 448, 480, 512, 544, 576, 608, 640, 672, 704, 736, 768, 800, 832, 864, 896, 928, 960, 992, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 320, 352, 384, 416, 448, 480, 512, 544, 576, 608, 640, 672, 704, 736, 768, 800, 832, 864, 896, 928, 960, 992, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
  static const int64_t table7[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
  // clang-format on
  bool valid;
  const uint8_t *srcinit = src;

  do {
    valid = false;
    int64_t r = table0[*src];
    if (r < 0) {
      break;
    }
    src++;
    int64_t r1 = table1[*src];
    if (r1 >= 0) {
      r |= r1;
      src++;
      int64_t r2 = table2[*src];
      if (r2 >= 0) {
        r |= r2;
        src++;
        int64_t r3 = table3[*src];
        if (r3 >= 0) {
          r |= r3;
          src++;
          int64_t r4 = table4[*src];
          if (r4 >= 0) {
            r |= r4;
            src++;
            int64_t r5 = table5[*src];
            if (r5 >= 0) {
              r |= r5;
              src++;
              int64_t r6 = table6[*src];
              if (r6 >= 0) {
                r |= r6;
                src++;
                int64_t r7 = table7[*src];
                if (r7 >= 0) {
                  r |= r7;
                  src++;
                  valid = true;
                }
              }
            }
          }
        }
      }
    }
    r = (long int)_bswap64((long long int)r);
    uint64_t rs = ((uint64_t)r >> (3 * 8));
    memcpy(dst, (const char *)&rs, 8);
    dst += 5;
  } while (valid);
  return (size_t)(src - srcinit);
}

size_t base32hex_swar(uint8_t *dst, const uint8_t *src) {
  const uint64_t nibble_mask = 0x0F0F0F0F0F0F0F0FULL;
  const uint64_t bit6_mask = 0x4040404040404040ULL;
  const uint64_t check_min = 0x3636363636363636ULL;
  const uint64_t check_max = 0x6060606060606060ULL;
  const uint64_t bit7_mask = 0x8080808080808080ULL;
  const uint8_t *srcinit = src;
  bool valid = true;
  do {
    uint64_t v;

    memcpy(&v, src, 8); // todo: big endian support

    uint64_t check = v; // if MSB of lane is set then bad char
    check |= ((v ^ nibble_mask) - check_min); // catch bad chars below 0x40
    uint64_t is_bit6 =
        (v & bit6_mask) >> 6; // split range between letters and digits
    v &= (is_bit6 + nibble_mask) | nibble_mask; // v &= (is_bit6) ? 0x1F : 0x0F
    check |= v - is_bit6;                       // catch 0x40 and 0x60
    v += is_bit6 * 9;                           // rebase letters
    check |= v + check_max; // catch 0x57..0x5F and 0x77..0x7F

    check &= bit7_mask;

    if (check != 0) { // has bad char, delimiter, or padding
      valid = false;
      unsigned trailing = (unsigned)__builtin_ctzll(check) / 8;
      if (trailing == 0) {
        break;
      }
      src += trailing;
      v &= (check ^ (check - 1)) / 8; // zero from bad char and beyond
    } else {
      src += 8;
    }

    const uint64_t m1 = 0x00FF00FF00FF00FFULL;
    const uint64_t m2 = 0x0000FFFF0000FFFFULL;
    v = ((v & m1) << 5) | ((v & ~m1) >> 8);
    v = ((v & m2) << 10) | ((v & ~m2) >> 16);
    v = (v << 44) | (v >> 8);
    v = __builtin_bswap64(v);
    // deliberately overwrites (8 bytes)
    memcpy(dst, &v, 8); // todo: big endian support
    dst += 5;
  } while (valid);
  return (size_t)(src - srcinit);
}